/**
  * ENSICAEN
  * 6, boulevard du Maréchal Juin
  * 14050 Caen Cedex
  *
  * This file is owned by ENSICAEN students
  * No portion of this document may be reproduced, copied or revised without written permission of the authors
  *
  * */

  /**
  * @file chaine.c
  *
  * Fonctions utiles à la gestion des chaines (listes de positions colorées)
  *
  * */

#include <stdlib.h>
#include <stdio.h>

#include "../includes/chaine.h"

Chaine chaine_creer(Couleur couleur)
{
    Chaine liste = malloc(sizeof(ensemble_colore));

    liste->taille = 0;
    liste->tete = NULL;
    liste->courant = NULL;
    liste->couleur = couleur;

    return liste;
}

void chaine_detruire(Chaine liste)
{
    element_position* tmp;

    chaine_tete(liste);

    if (!chaine_vide(liste))
    {
        do
        {
            tmp = chaine_courant(liste)->suivant;

            free(chaine_courant(liste));

            liste->courant = tmp;
        } while (tmp != NULL);
    }

    free(liste);
}

int chaine_vide(Chaine liste)
{
    if (liste->tete == NULL)
        return 1;

    return 0;
}

void chaine_ajouter(Position position, Chaine liste)
{
    element_position* element = malloc(sizeof(element_position));

    element->position = position;
    element->suivant = NULL;

    if (chaine_vide(liste))
    {
        liste->tete = element;
        liste->courant = element;
    }
    else
    {
        while (chaine_suivant(liste)) {}

        chaine_courant(liste)->suivant = element;
    }

    liste->taille++;
}

int chaine_appartient(Position position, Chaine liste)
{
    if (chaine_vide(liste))
        return 0;

    chaine_tete(liste);

    while (!(chaine_courant(liste)->position.x == position.x && chaine_courant(liste)->position.y == position.y) && chaine_suivant(liste)) {}

    if (chaine_courant(liste)->position.x == position.x && chaine_courant(liste)->position.y == position.y)
        return 1;

    return 0;
}

int chaine_est_identique(Chaine chaine1, Chaine chaine2)
{
    if (chaine_vide(chaine1) && chaine_vide(chaine2))
        return 1;

    if (chaine_vide(chaine1) || chaine_vide(chaine2))
        return 0;

    int k = 0;

    if (chaine1->couleur == chaine2->couleur && chaine1->taille == chaine2->taille)
    {
        chaine_tete(chaine1);

        do
        {
            if (chaine_appartient(chaine_courant(chaine1)->position, chaine2))
                k++;
        } while (chaine_suivant(chaine1));

        if (k == chaine1->taille)
            return 1;
    }

    return 0;
}

void chaine_tete(Chaine liste)
{
    if (!chaine_vide(liste))
        liste->courant = liste->tete;
}

int chaine_suivant(Chaine liste)
{
    if (chaine_vide(liste))
        return 0;

    if (chaine_courant(liste)->suivant != NULL)
    {
        liste->courant = chaine_courant(liste)->suivant;

        return 1;
    }

    return 0;
}

element_position* chaine_courant(Chaine liste)
{
    if (!chaine_vide(liste))
        return liste->courant;

    return NULL;
}
